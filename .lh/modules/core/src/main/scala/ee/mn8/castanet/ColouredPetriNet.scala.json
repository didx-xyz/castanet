{
    "sourceFile": "modules/core/src/main/scala/ee/mn8/castanet/ColouredPetriNet.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 73,
            "patches": [
                {
                    "date": 1629275319970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1629278853332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,11 @@\n import scala.collection.immutable.ListSet\n import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n+import us.oyanglul.dhall.generic.Decoder\n \n+\n sealed trait PetriElement\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n"
                },
                {
                    "date": 1629279134343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElement:\n+enum Arc extends PetriElementderives Decoder:\n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629279140658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElementderives Decoder:\n+enum Arc extends PetriElement derives Decoder:\n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629279163611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n import scala.concurrent.duration.*\n import us.oyanglul.dhall.generic.Decoder\n \n \n-sealed trait PetriElement\n+sealed trait PetriElement derives Decoder\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n"
                },
                {
                    "date": 1629279178740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n import scala.concurrent.duration.*\n import us.oyanglul.dhall.generic.Decoder\n \n \n-sealed trait PetriElement derives Decoder\n+sealed trait PetriElement \n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n"
                },
                {
                    "date": 1629279187198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement:\n+enum LinkableElement extends PetriElement derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n"
                },
                {
                    "date": 1629376161871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n+  \n enum LinkableElement extends PetriElement derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n"
                },
                {
                    "date": 1629376199820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,17 +52,17 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-  \n+\n enum LinkableElement extends PetriElement derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n-\n+case class\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629376225537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n-case class\n+\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629376232595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n-\n+type\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629376243642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,8 +59,10 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n+\n+  \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n type\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376253767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n \n-  \n+type Elements  \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n type\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376267352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n \n-type Elements  \n+type Elements = ListSet[LinkableElement]  \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n type\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376283281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,10 +61,10 @@\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n \n type Elements = ListSet[LinkableElement]  \n-type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n-type\n+type PetriGraph = SortedMap[NodeId, Elem]\n+\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629376288557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n \n type Elements = ListSet[LinkableElement]  \n-type PetriGraph = SortedMap[NodeId, Elem]\n+type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n"
                },
                {
                    "date": 1629376299114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,8 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-\n type Elements = ListSet[LinkableElement]  \n type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629376307843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-type Elements = ListSet[LinkableElement]  \n+type Elements = ListSet[LinkableElement] derive \n type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376314688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-type Elements = ListSet[LinkableElement] derive \n+type Elements = ListSet[LinkableElement] derive s \n type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376340776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,8 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-type Elements = ListSet[LinkableElement] derive s \n type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376360839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,8 +59,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n+type Elements = ListSet[LinkableElement] derives Decoder \n type PetriGraph = SortedMap[NodeId, Elements]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629376366393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,11 +59,12 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-type Elements = ListSet[LinkableElement] derives Decoder \n-type PetriGraph = SortedMap[NodeId, Elements]\n \n+type Elements = ListSet[LinkableElement]  \n+type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n+\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629376371596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,8 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-\n type Elements = ListSet[LinkableElement]  \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629376376677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,8 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-\n enum LinkableElement extends PetriElement derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n"
                },
                {
                    "date": 1629379311565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,10 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-type Elements = ListSet[LinkableElement]  \n+case class Elements(l: List[List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n+\n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n"
                },
                {
                    "date": 1629379444588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class Elements(l: List[List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: List[List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629379536445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement derives Decoder:\n+enum LinkableElement extends PetriElement //derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n"
                },
                {
                    "date": 1629379544340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement //derives Decoder:\n+enum LinkableElement extends PetriElement: //derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n"
                },
                {
                    "date": 1629379565749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElement derives Decoder:\n+enum Arc extends PetriElement : //derives Decoder:\n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629380652595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: List[List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: [List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380668875,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: [List[LinkableElement]] = List[List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380674285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380685065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]()) derives Decoder\n+case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380691909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: [List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: [List[LinkableElement]] = [List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380698866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: [List[LinkableElement]] = [List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629380705866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: List[LinkableElement] = [List[LinkableElement]]()) derives Decoder\n+case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) derives Decoder\n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629384777421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement: //derives Decoder:\n+enum LinkableElement extends PetriElement: /\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n"
                },
                {
                    "date": 1629384795297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,15 +52,15 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement: /\n+enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n \n-case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) derives Decoder\n+case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n"
                },
                {
                    "date": 1629384815286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElement : //derives Decoder:\n+enum Arc extends PetriElement : \n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629384822268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,11 +38,11 @@\n import scala.collection.immutable.ListSet\n import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n-import us.oyanglul.dhall.generic.Decoder\n \n \n+\n sealed trait PetriElement \n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n"
                },
                {
                    "date": 1629384848923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -121,26 +121,9 @@\n   \n case class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n     val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n \n-/* object PetriDerivation:   \n- import LinkableElement._\n- import Service._   \n- import Arc._\n- given  encodePetriElemnt: Encoder[PetriElement] = Encoder.instance {\n-    case place @ Place(_,_,_) => place.asJson\n-    case transition @ Transition(_,_,_,_) => transition.asJson\n-    case timed @ Timed(_,_,_) => timed.asJson\n-    case weighted @ Weighted(_,_,_) => weighted.asJson\n-  }\n \n-  given decodeEvent: Decoder[PetriElement] =\n-    List[Decoder[PetriElement]](\n-      Decoder[Place].widen,\n-      Decoder[Transition].widen,\n-      Decoder[Timed].widen,\n-      Decoder[Weighted].widen\n-    ).reduceLeft(_ or _) */\n \n trait ColouredPetriNet:\n   import LinkableElement._\n   import cats.data.State\n"
                },
                {
                    "date": 1629461942026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement \n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n@@ -121,10 +121,8 @@\n   \n case class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n     val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n \n-\n-\n trait ColouredPetriNet:\n   import LinkableElement._\n   import cats.data.State\n \n"
                },
                {
                    "date": 1629461947885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement \n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement:\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n"
                },
                {
                    "date": 1629462278790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,8 +57,9 @@\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement:\n+    de\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n"
                },
                {
                    "date": 1629462295040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,10 +56,10 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement:\n-    de\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+    def run \n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n"
                },
                {
                    "date": 1629462316008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement =\n     def run \n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462321960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement =\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n     def run \n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462330866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,10 +56,10 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n-    def run \n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+    def run\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n"
                },
                {
                    "date": 1629462337688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n-    def run\n+    def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n"
                },
                {
                    "date": 1629462582639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+  case class Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462674090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case class Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462683959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement \n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462690269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n enum LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement \n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement {\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462707629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,13 +52,13 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement: \n+trait  LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement {\n+  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462718812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n trait  LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n-  case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n+case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n"
                },
                {
                    "date": 1629462724312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n trait  LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n+case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462737018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n \n trait  LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n-case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n+case class Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n"
                },
                {
                    "date": 1629462748868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n trait  LinkableElement extends PetriElement: \n   val id: NodeId\n   val name: String\n case class Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n+case class Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n     def run() = ???\n \n case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n \n"
                },
                {
                    "date": 1629462778205,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,9 +86,9 @@\n   def apply(cpn: ColouredPetriNet, stateVector: BitVector): Markers =\n     Markers(\n       cpn,\n       cpn.elements.values\n-        .collect { case p: LinkableElement.Place =>\n+        .collect { case p: Place =>\n           (p.id, p.capacity)\n         }\n         .foldLeft((SortedMap[NodeId, BitVector](), stateVector))((ms, kv) =>\n           val t = ms._2.splitAt(kv._2)\n"
                },
                {
                    "date": 1629462793662,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n   def apply(cpn: ColouredPetriNet): Markers =\n     Markers(\n       cpn,\n       cpn.elements.values\n-        .collect { case p: LinkableElement.Place =>\n+        .collect { case p: Place =>\n           (p.id, BitVector.fill(p.capacity)(false))\n         }\n         .to(collection.immutable.SortedMap)\n     )\n"
                },
                {
                    "date": 1629462811783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,9 +101,9 @@\n     Markers(cpn, BitVector.fromValidBase64(markers, Bases.Alphabets.Base64))\n \n end Markers    \n case class Markers(cpn: ColouredPetriNet, state: SortedMap[NodeId, BitVector]):\n-  import LinkableElement._\n+  //import LinkableElement._\n \n   val places = cpn.elements.values.collect { case p: Place => (p.id, p) }.toMap\n   def setMarker(m: Marker) =\n     if state.keySet.contains(m.id) then Markers(cpn, state ++ m.asMap)\n"
                },
                {
                    "date": 1629462823795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -123,9 +123,9 @@\n case class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n     val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n \n trait ColouredPetriNet:\n-  import LinkableElement._\n+  //import LinkableElement._\n   import cats.data.State\n \n   val elements: SortedMap[NodeId, LinkableElement]\n   val graph: PetriGraph\n"
                },
                {
                    "date": 1629463917552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,30 +41,10 @@\n import scala.concurrent.duration.*\n \n \n \n-sealed trait PetriElement \n-sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n-type NodeId = Int\n \n-enum Arc extends PetriElement : \n-  val from: NodeId\n-  val to: NodeId\n-  case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n-  case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n-\n-trait  LinkableElement extends PetriElement: \n-  val id: NodeId\n-  val name: String\n-case class Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n-case class Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement :\n-    def run() = ???\n-\n-case class PetriElements(l: List[LinkableElement] = List[LinkableElement]()) \n-\n-type PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n-\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629463993832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,8 @@\n import scodec.bits.ByteOrdering\n \n import java.nio.file.Paths\n import scala.collection.immutable.ListSet\n-import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n \n \n"
                },
                {
                    "date": 1629463999738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,8 +35,9 @@\n import scodec.bits.ByteOrdering\n \n import java.nio.file.Paths\n import scala.collection.immutable.ListSet\n+import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n \n \n"
                },
                {
                    "date": 1629464044596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,12 +39,8 @@\n import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n \n-\n-\n-\n-\n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n   val asMap          = Map(id -> bits)\n   override def empty = Marker(id, BitVector.empty)\n   def add(m: Marker) = combine(this, m)\n"
                },
                {
                    "date": 1629723122511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,26 +18,23 @@\n package castanet\n \n import cats.*\n import cats.effect.*\n-import cats.implicits.*\n-import cats.instances.all.*\n-import cats.syntax.all.*\n+import cats.cats.cats.implicits.*\n+import cats.cats.cats.instances.all.*\n+import cats.cats.cats.syntax.all.*\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n-import io.circe.generic.auto.*\n-import io.circe.parser.*\n-import io.circe.syntax.*\n-import io.circe.yaml.*\n+import io.circe.io.circe.io.circe.generic.auto.*\n+import io.circe.io.circe.io.circe.parser.*\n+import io.circe.io.circe.io.circe.syntax.*\n+import io.circe.io.circe.io.circe.yaml.*\n import monocle.Lens\n import monocle.syntax.all.*\n-import scodec.bits.Bases\n-import scodec.bits.BitVector\n-import scodec.bits.ByteOrdering\n+import scodec.bits.{Bases, BitVector, ByteOrdering}\n \n import java.nio.file.Paths\n-import scala.collection.immutable.ListSet\n-import scala.collection.immutable.SortedMap\n+import scala.collection.immutable.{ListSet, SortedMap}\n import scala.collection.mutable\n import scala.concurrent.duration.*\n \n case class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n@@ -147,9 +144,9 @@\n     )\n end ColouredPetriNet\n \n case class PetriNetBuilder(nodes: ListSet[PetriElement] = ListSet()) extends ConcatenableProcess:\n-  import Arc._\n+  import Arc.*\n // Set is a Semigroup but not ListSet - add monoid behaviour\n   given [T]: Semigroup[ListSet[T]] = Semigroup.instance[ListSet[T]](_ ++ _)\n \n   def empty = PetriNetBuilder()\n"
                },
                {
                    "date": 1629723128097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n package castanet\n \n import cats.*\n import cats.effect.*\n-import cats.cats.cats.implicits.*\n+import cats.implicits.*\n import cats.cats.cats.instances.all.*\n import cats.cats.cats.syntax.all.*\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n"
                },
                {
                    "date": 1629723138300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,10 +19,10 @@\n \n import cats.*\n import cats.effect.*\n import cats.implicits.*\n-import cats.cats.cats.instances.all.*\n-import cats.cats.cats.syntax.all.*\n+import cats.instances.all.*\n+import cats.syntax.all.*\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n import io.circe.io.circe.io.circe.generic.auto.*\n import io.circe.io.circe.io.circe.parser.*\n"
                },
                {
                    "date": 1629723150314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n import cats.instances.all.*\n import cats.syntax.all.*\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n-import io.circe.io.circe.io.circe.generic.auto.*\n+import io.circe.generic.auto.*\n import io.circe.io.circe.io.circe.parser.*\n import io.circe.io.circe.io.circe.syntax.*\n import io.circe.io.circe.io.circe.yaml.*\n import monocle.Lens\n"
                },
                {
                    "date": 1629723155480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n import cats.syntax.all.*\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n import io.circe.generic.auto.*\n-import io.circe.io.circe.io.circe.parser.*\n+import io.circe.parser.*\n import io.circe.io.circe.io.circe.syntax.*\n import io.circe.io.circe.io.circe.yaml.*\n import monocle.Lens\n import monocle.syntax.all.*\n"
                },
                {
                    "date": 1629723163343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,10 +25,10 @@\n import ee.mn8.castanet.PetriElement\n import io.circe.*\n import io.circe.generic.auto.*\n import io.circe.parser.*\n-import io.circe.io.circe.io.circe.syntax.*\n-import io.circe.io.circe.io.circe.yaml.*\n+import io.circe.syntax.*\n+import io.circe.yaml.*\n import monocle.Lens\n import monocle.syntax.all.*\n import scodec.bits.{Bases, BitVector, ByteOrdering}\n \n"
                },
                {
                    "date": 1629806016729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,12 +88,9 @@\n   )\n   def serialize = toStateVector.toBase64\n end Markers\n \n-case class ArcId(from: Int, to: Int):\n-  import scala.math.Ordered.orderingToOrdered \n-  def compare(that: ArcId): Int = (this.from, this.to) compare (that.from, that.to)\n-  \n+\n case class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n     val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n \n trait ColouredPetriNet:\n"
                },
                {
                    "date": 1629806043399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,8 @@\n   )\n   def serialize = toStateVector.toBase64\n end Markers\n \n-\n case class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n     val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n \n trait ColouredPetriNet:\n"
                }
            ],
            "date": 1629275319969,
            "name": "Commit-0",
            "content": "/*\n * Copyright 2021 Ian de Beer\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ee.mn8\npackage castanet\n\nimport cats.*\nimport cats.effect.*\nimport cats.implicits.*\nimport cats.instances.all.*\nimport cats.syntax.all.*\nimport ee.mn8.castanet.PetriElement\nimport io.circe.*\nimport io.circe.generic.auto.*\nimport io.circe.parser.*\nimport io.circe.syntax.*\nimport io.circe.yaml.*\nimport monocle.Lens\nimport monocle.syntax.all.*\nimport scodec.bits.Bases\nimport scodec.bits.BitVector\nimport scodec.bits.ByteOrdering\n\nimport java.nio.file.Paths\nimport scala.collection.immutable.ListSet\nimport scala.collection.immutable.SortedMap\nimport scala.collection.mutable\nimport scala.concurrent.duration.*\n\nsealed trait PetriElement\nsealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n\ntype NodeId = Int\n\nenum Arc extends PetriElement:\n  val from: NodeId\n  val to: NodeId\n  case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n  case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n\nenum LinkableElement extends PetriElement:\n  val id: NodeId\n  val name: String\n  case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n\ntype PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n\ncase class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n  val asMap          = Map(id -> bits)\n  override def empty = Marker(id, BitVector.empty)\n  def add(m: Marker) = combine(this, m)\n  override def combine(m1: Marker, m2: Marker): Marker =\n    if m1.id == m2.id then Marker(m1.id, (m1.bits | m2.bits))\n    else m1\n\nobject Markers:\n  def apply(cpn: ColouredPetriNet): Markers =\n    Markers(\n      cpn,\n      cpn.elements.values\n        .collect { case p: LinkableElement.Place =>\n          (p.id, BitVector.fill(p.capacity)(false))\n        }\n        .to(collection.immutable.SortedMap)\n    )\n\n  def apply(cpn: ColouredPetriNet, stateVector: BitVector): Markers =\n    Markers(\n      cpn,\n      cpn.elements.values\n        .collect { case p: LinkableElement.Place =>\n          (p.id, p.capacity)\n        }\n        .foldLeft((SortedMap[NodeId, BitVector](), stateVector))((ms, kv) =>\n          val t = ms._2.splitAt(kv._2)\n          (ms._1 ++ Map(kv._1 -> t._1), t._2)\n        )\n        ._1\n    )\n\n  def apply(cpn: ColouredPetriNet, markers: String): Markers =\n    Markers(cpn, BitVector.fromValidBase64(markers, Bases.Alphabets.Base64))\n\nend Markers    \ncase class Markers(cpn: ColouredPetriNet, state: SortedMap[NodeId, BitVector]):\n  import LinkableElement._\n\n  val places = cpn.elements.values.collect { case p: Place => (p.id, p) }.toMap\n  def setMarker(m: Marker) =\n    if state.keySet.contains(m.id) then Markers(cpn, state ++ m.asMap)\n    else this\n  def toStateVector = state.foldLeft(BitVector.empty)((b, kv) =>\n    kv._2 match\n      case BitVector.empty => b ++ BitVector.fill(places(kv._1).capacity.toLong)(false)\n      case v: BitVector    => b ++ v\n  )\n  def serialize = toStateVector.toBase64\nend Markers\n\ncase class ArcId(from: Int, to: Int):\n  import scala.math.Ordered.orderingToOrdered \n  def compare(that: ArcId): Int = (this.from, this.to) compare (that.from, that.to)\n  \ncase class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n    val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n\n/* object PetriDerivation:   \n import LinkableElement._\n import Service._   \n import Arc._\n given  encodePetriElemnt: Encoder[PetriElement] = Encoder.instance {\n    case place @ Place(_,_,_) => place.asJson\n    case transition @ Transition(_,_,_,_) => transition.asJson\n    case timed @ Timed(_,_,_) => timed.asJson\n    case weighted @ Weighted(_,_,_) => weighted.asJson\n  }\n\n  given decodeEvent: Decoder[PetriElement] =\n    List[Decoder[PetriElement]](\n      Decoder[Place].widen,\n      Decoder[Transition].widen,\n      Decoder[Timed].widen,\n      Decoder[Weighted].widen\n    ).reduceLeft(_ or _) */\n\ntrait ColouredPetriNet:\n  import LinkableElement._\n  import cats.data.State\n\n  val elements: SortedMap[NodeId, LinkableElement]\n  val graph: PetriGraph\n  val arcs: Map[ArcId, Long]\n\n  /**\n   * Providing a state monad for traversing the Petri Net\n   * \n  */\n   def step:State[Step,Markers] = State(step => \n    // all arcs that come from places with tokens\n    val flows: Map[ArcId, Long] =  arcs.filter(a => step.inits.keySet.contains(a._1.from))\n\n    // all arcs that have a smaller guards than the number of markers in the place - i.e. it can step \n    val steps: Map[ArcId, Long] = flows.filter(f => f._2 <= step.inits(f._1.from).populationCount)\n\n    // all arcs from allowable transitions (steps) and their weights \n    val nextFlows: Map[ArcId, Long] = for\n      s <- steps\n      n <- graph(s._1.to)\n    yield (ArcId(s._1.to, n.id), arcs(ArcId(s._1.to, n.id)))\n\n    // all arcs that have a wight that is less than the capacity allowed by the destination place\n    val nextSteps = nextFlows.filter(f =>\n      f._2 <= elements(f._1.to)\n        .asInstanceOf[Place]\n        .capacity - step.markers.state(f._1.to).populationCount\n    )\n\n    // remove markers from the origin place of allowed steps \n    val m1 = steps.foldLeft(step.markers)((m,s) => m.setMarker(Marker(s._1.from,step.markers.state(s._1.from).shiftLeft(s._2))))\n\n    // add markers to the destination place (as per the weight from the transition)\n    val m2 = nextFlows.foldLeft(m1)((m,s) => m.setMarker(Marker(s._1.to,step.markers.state(s._1.to).patch(step.markers.state(s._1.to).populationCount, BitVector.fill(s._2)(true)))))\n    \n    // this side effect must be moved to the IO monad \n    if step.show then\n        PetriPrinter(fileName = s\"step${step.count}\", petriNet = this).print(markers = Option(step.markers), steps = Option(steps ++ nextSteps)) \n    else ()   \n    \n    // update the state and return the markers resulting from the step (reduced origin and increased destination steps)\n    (Step(m2,step.show,step.count + 1),m2)\n    )\nend ColouredPetriNet\n\ncase class PetriNetBuilder(nodes: ListSet[PetriElement] = ListSet()) extends ConcatenableProcess:\n  import Arc._\n// Set is a Semigroup but not ListSet - add monoid behaviour\n  given [T]: Semigroup[ListSet[T]] = Semigroup.instance[ListSet[T]](_ ++ _)\n\n  def empty = PetriNetBuilder()\n  override def combine(n: PetriElement, a: PetriElement): ConcatenableProcess =\n    PetriNetBuilder().add(n).add(a)\n\n  def add[P <: PetriElement](p: P): PetriNetBuilder =\n    this.focus(_.nodes).replace(nodes + p)\n  def addAll[P <: PetriElement](p: ListSet[P]): PetriNetBuilder =\n    this.focus(_.nodes).replace(nodes ++ p)\n  def build() = new ColouredPetriNet:\n    override val elements = nodes.foldRight(SortedMap[NodeId, LinkableElement]())((n, m) =>\n      n match\n        case p: LinkableElement => m + (p.id -> p)\n        case _                  => m\n    )\n    override val graph = nodes.foldRight(SortedMap[NodeId, ListSet[LinkableElement]]())((n, m) =>\n      n match\n        case t: Arc =>\n          m |+| SortedMap[NodeId, ListSet[LinkableElement]](t.from -> ListSet(elements(t.to)))\n        case _ => m\n    )\n\n    override val arcs =  nodes.collect {\n      case w: Weighted => ArcId(w.from, w.to) -> w.weight.toLong\n      case t: Timed    => ArcId(t.from, t.to) -> t.interval\n    }.toMap\n\n"
        }
    ]
}