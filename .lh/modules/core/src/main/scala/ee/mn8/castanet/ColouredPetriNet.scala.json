{
    "sourceFile": "modules/core/src/main/scala/ee/mn8/castanet/ColouredPetriNet.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1629275319970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1629278853332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,9 +38,11 @@\n import scala.collection.immutable.ListSet\n import scala.collection.immutable.SortedMap\n import scala.collection.mutable\n import scala.concurrent.duration.*\n+import us.oyanglul.dhall.generic.Decoder\n \n+\n sealed trait PetriElement\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n"
                },
                {
                    "date": 1629279134343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElement:\n+enum Arc extends PetriElementderives Decoder:\n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629279140658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n-enum Arc extends PetriElementderives Decoder:\n+enum Arc extends PetriElement derives Decoder:\n   val from: NodeId\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n"
                },
                {
                    "date": 1629279163611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n import scala.concurrent.duration.*\n import us.oyanglul.dhall.generic.Decoder\n \n \n-sealed trait PetriElement\n+sealed trait PetriElement derives Decoder\n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n"
                },
                {
                    "date": 1629279178740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n import scala.concurrent.duration.*\n import us.oyanglul.dhall.generic.Decoder\n \n \n-sealed trait PetriElement derives Decoder\n+sealed trait PetriElement \n sealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n \n type NodeId = Int\n \n"
                },
                {
                    "date": 1629279187198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n   val to: NodeId\n   case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n   case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n \n-enum LinkableElement extends PetriElement:\n+enum LinkableElement extends PetriElement derives Decoder:\n   val id: NodeId\n   val name: String\n   case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n   case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n"
                }
            ],
            "date": 1629275319969,
            "name": "Commit-0",
            "content": "/*\n * Copyright 2021 Ian de Beer\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ee.mn8\npackage castanet\n\nimport cats.*\nimport cats.effect.*\nimport cats.implicits.*\nimport cats.instances.all.*\nimport cats.syntax.all.*\nimport ee.mn8.castanet.PetriElement\nimport io.circe.*\nimport io.circe.generic.auto.*\nimport io.circe.parser.*\nimport io.circe.syntax.*\nimport io.circe.yaml.*\nimport monocle.Lens\nimport monocle.syntax.all.*\nimport scodec.bits.Bases\nimport scodec.bits.BitVector\nimport scodec.bits.ByteOrdering\n\nimport java.nio.file.Paths\nimport scala.collection.immutable.ListSet\nimport scala.collection.immutable.SortedMap\nimport scala.collection.mutable\nimport scala.concurrent.duration.*\n\nsealed trait PetriElement\nsealed trait ConcatenableProcess extends PetriElement with Monoid[PetriElement]\n\ntype NodeId = Int\n\nenum Arc extends PetriElement:\n  val from: NodeId\n  val to: NodeId\n  case Timed(from: NodeId, to: NodeId, interval: Long) extends Arc\n  case Weighted(from: NodeId, to: NodeId, weight: Int) extends Arc\n\nenum LinkableElement extends PetriElement:\n  val id: NodeId\n  val name: String\n  case Place(id: NodeId, name: String, capacity: Int) extends LinkableElement\n  case Transition(id: NodeId, name: String, service:Service, rpc:RPC) extends LinkableElement\n\ntype PetriGraph = SortedMap[NodeId, ListSet[LinkableElement]]\n\ncase class Marker(id: NodeId, bits: BitVector) extends Monoid[Marker]:\n  val asMap          = Map(id -> bits)\n  override def empty = Marker(id, BitVector.empty)\n  def add(m: Marker) = combine(this, m)\n  override def combine(m1: Marker, m2: Marker): Marker =\n    if m1.id == m2.id then Marker(m1.id, (m1.bits | m2.bits))\n    else m1\n\nobject Markers:\n  def apply(cpn: ColouredPetriNet): Markers =\n    Markers(\n      cpn,\n      cpn.elements.values\n        .collect { case p: LinkableElement.Place =>\n          (p.id, BitVector.fill(p.capacity)(false))\n        }\n        .to(collection.immutable.SortedMap)\n    )\n\n  def apply(cpn: ColouredPetriNet, stateVector: BitVector): Markers =\n    Markers(\n      cpn,\n      cpn.elements.values\n        .collect { case p: LinkableElement.Place =>\n          (p.id, p.capacity)\n        }\n        .foldLeft((SortedMap[NodeId, BitVector](), stateVector))((ms, kv) =>\n          val t = ms._2.splitAt(kv._2)\n          (ms._1 ++ Map(kv._1 -> t._1), t._2)\n        )\n        ._1\n    )\n\n  def apply(cpn: ColouredPetriNet, markers: String): Markers =\n    Markers(cpn, BitVector.fromValidBase64(markers, Bases.Alphabets.Base64))\n\nend Markers    \ncase class Markers(cpn: ColouredPetriNet, state: SortedMap[NodeId, BitVector]):\n  import LinkableElement._\n\n  val places = cpn.elements.values.collect { case p: Place => (p.id, p) }.toMap\n  def setMarker(m: Marker) =\n    if state.keySet.contains(m.id) then Markers(cpn, state ++ m.asMap)\n    else this\n  def toStateVector = state.foldLeft(BitVector.empty)((b, kv) =>\n    kv._2 match\n      case BitVector.empty => b ++ BitVector.fill(places(kv._1).capacity.toLong)(false)\n      case v: BitVector    => b ++ v\n  )\n  def serialize = toStateVector.toBase64\nend Markers\n\ncase class ArcId(from: Int, to: Int):\n  import scala.math.Ordered.orderingToOrdered \n  def compare(that: ArcId): Int = (this.from, this.to) compare (that.from, that.to)\n  \ncase class Step(markers:Markers, show: Boolean = false, count:  Int = 0) :\n    val inits: SortedMap[NodeId, BitVector] = markers.state.filter(m => m._2 > BitVector.empty.padRight(m._2.size))\n\n/* object PetriDerivation:   \n import LinkableElement._\n import Service._   \n import Arc._\n given  encodePetriElemnt: Encoder[PetriElement] = Encoder.instance {\n    case place @ Place(_,_,_) => place.asJson\n    case transition @ Transition(_,_,_,_) => transition.asJson\n    case timed @ Timed(_,_,_) => timed.asJson\n    case weighted @ Weighted(_,_,_) => weighted.asJson\n  }\n\n  given decodeEvent: Decoder[PetriElement] =\n    List[Decoder[PetriElement]](\n      Decoder[Place].widen,\n      Decoder[Transition].widen,\n      Decoder[Timed].widen,\n      Decoder[Weighted].widen\n    ).reduceLeft(_ or _) */\n\ntrait ColouredPetriNet:\n  import LinkableElement._\n  import cats.data.State\n\n  val elements: SortedMap[NodeId, LinkableElement]\n  val graph: PetriGraph\n  val arcs: Map[ArcId, Long]\n\n  /**\n   * Providing a state monad for traversing the Petri Net\n   * \n  */\n   def step:State[Step,Markers] = State(step => \n    // all arcs that come from places with tokens\n    val flows: Map[ArcId, Long] =  arcs.filter(a => step.inits.keySet.contains(a._1.from))\n\n    // all arcs that have a smaller guards than the number of markers in the place - i.e. it can step \n    val steps: Map[ArcId, Long] = flows.filter(f => f._2 <= step.inits(f._1.from).populationCount)\n\n    // all arcs from allowable transitions (steps) and their weights \n    val nextFlows: Map[ArcId, Long] = for\n      s <- steps\n      n <- graph(s._1.to)\n    yield (ArcId(s._1.to, n.id), arcs(ArcId(s._1.to, n.id)))\n\n    // all arcs that have a wight that is less than the capacity allowed by the destination place\n    val nextSteps = nextFlows.filter(f =>\n      f._2 <= elements(f._1.to)\n        .asInstanceOf[Place]\n        .capacity - step.markers.state(f._1.to).populationCount\n    )\n\n    // remove markers from the origin place of allowed steps \n    val m1 = steps.foldLeft(step.markers)((m,s) => m.setMarker(Marker(s._1.from,step.markers.state(s._1.from).shiftLeft(s._2))))\n\n    // add markers to the destination place (as per the weight from the transition)\n    val m2 = nextFlows.foldLeft(m1)((m,s) => m.setMarker(Marker(s._1.to,step.markers.state(s._1.to).patch(step.markers.state(s._1.to).populationCount, BitVector.fill(s._2)(true)))))\n    \n    // this side effect must be moved to the IO monad \n    if step.show then\n        PetriPrinter(fileName = s\"step${step.count}\", petriNet = this).print(markers = Option(step.markers), steps = Option(steps ++ nextSteps)) \n    else ()   \n    \n    // update the state and return the markers resulting from the step (reduced origin and increased destination steps)\n    (Step(m2,step.show,step.count + 1),m2)\n    )\nend ColouredPetriNet\n\ncase class PetriNetBuilder(nodes: ListSet[PetriElement] = ListSet()) extends ConcatenableProcess:\n  import Arc._\n// Set is a Semigroup but not ListSet - add monoid behaviour\n  given [T]: Semigroup[ListSet[T]] = Semigroup.instance[ListSet[T]](_ ++ _)\n\n  def empty = PetriNetBuilder()\n  override def combine(n: PetriElement, a: PetriElement): ConcatenableProcess =\n    PetriNetBuilder().add(n).add(a)\n\n  def add[P <: PetriElement](p: P): PetriNetBuilder =\n    this.focus(_.nodes).replace(nodes + p)\n  def addAll[P <: PetriElement](p: ListSet[P]): PetriNetBuilder =\n    this.focus(_.nodes).replace(nodes ++ p)\n  def build() = new ColouredPetriNet:\n    override val elements = nodes.foldRight(SortedMap[NodeId, LinkableElement]())((n, m) =>\n      n match\n        case p: LinkableElement => m + (p.id -> p)\n        case _                  => m\n    )\n    override val graph = nodes.foldRight(SortedMap[NodeId, ListSet[LinkableElement]]())((n, m) =>\n      n match\n        case t: Arc =>\n          m |+| SortedMap[NodeId, ListSet[LinkableElement]](t.from -> ListSet(elements(t.to)))\n        case _ => m\n    )\n\n    override val arcs =  nodes.collect {\n      case w: Weighted => ArcId(w.from, w.to) -> w.weight.toLong\n      case t: Timed    => ArcId(t.from, t.to) -> t.interval\n    }.toMap\n\n"
        }
    ]
}