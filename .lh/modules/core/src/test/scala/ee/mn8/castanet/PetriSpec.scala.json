{
    "sourceFile": "modules/core/src/test/scala/ee/mn8/castanet/PetriSpec.scala",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1629462613091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1629462918826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,8 @@\n     //println(c2.as[Json].getOrElse(Json.Null))\n   }\n \n   test(\"build petri net\") {\n-    import LinkableElement._\n     import Arc._\n     val jp1 = \"\"\"{\"id\":1,\"name\":\"start\",\"capacity\":1}\"\"\"\n \n     val p1: Place = decode[Place](jp1).getOrElse(Place(999, \"Error\", 0))\n"
                },
                {
                    "date": 1629883937682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,21 @@\n package ee.mn8.castanet\n-import munit._\n+import cats.data.State\n import cats.syntax.functor._\n-import io.circe._, io.circe.parser._\n-import io.circe.generic.auto._\n-import io.circe.syntax._\n+import io.circe.Decoder\n+import io.circe.Encoder\n+import io.circe._\n+import io.circe.generic.auto.*\n+import io.circe.generic.auto.*\n+import io.circe.parser.*\n import io.circe.parser.decode\n-import io.circe.{Decoder, Encoder}\n-import io.circe.syntax._\n-import io.circe.generic.auto._\n+import io.circe.syntax.*\n+import io.circe.syntax.*\n+import munit.*\n+import scodec.bits.*\n+\n+import scala.collection.immutable.ListSet\n import scala.io.Source\n-import scala.collection.immutable.ListSet\n-import scodec.bits._\n-import cats.data.State\n import scala.quoted.*\n \n class PetriSpec extends FunSuite {\n   val t = Source\n"
                },
                {
                    "date": 1629883955371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n package ee.mn8.castanet\n import cats.data.State\n-import cats.syntax.functor._\n+import cats.syntax.functor.*\n import io.circe.Decoder\n import io.circe.Encoder\n import io.circe._\n import io.circe.generic.auto.*\n"
                },
                {
                    "date": 1629883963177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n import cats.data.State\n import cats.syntax.functor.*\n import io.circe.Decoder\n import io.circe.Encoder\n-import io.circe._\n+import io.circe.*\n import io.circe.generic.auto.*\n import io.circe.generic.auto.*\n import io.circe.parser.*\n import io.circe.parser.decode\n"
                }
            ],
            "date": 1629462613091,
            "name": "Commit-0",
            "content": "package ee.mn8.castanet\nimport munit._\nimport cats.syntax.functor._\nimport io.circe._, io.circe.parser._\nimport io.circe.generic.auto._\nimport io.circe.syntax._\nimport io.circe.parser.decode\nimport io.circe.{Decoder, Encoder}\nimport io.circe.syntax._\nimport io.circe.generic.auto._\nimport scala.io.Source\nimport scala.collection.immutable.ListSet\nimport scodec.bits._\nimport cats.data.State\nimport scala.quoted.*\n\nclass PetriSpec extends FunSuite {\n  val t = Source\n    .fromFile(\n      \"/Users/ian/dev/castanet/modules/protocol/src/main/workflow/workflow.json\"\n    )\n    .mkString\n  val j               = parse(t).getOrElse(Json.Null)\n  val k               = parse(\"error\").getOrElse(Json.Null)\n  val cursor: HCursor = j.hcursor\n\n  // val c = cursor.downField(\"spec\").downField(\"templates\")\n  test(\"extract path\") {\n    println(j)\n    println(\"_\" * 10)\n\n    println(j.as[Json])\n    val c1 = j.hcursor.downField(\"spec\").downField(\"templates\").downArray\n    println(\"_\" * 10)\n    println(c1.as[Json])\n    val c2 = cursor\n      .downField(\"spec\")\n      .downField(\"templates\")\n      .downN(1)\n      .downField(\"dag\") //.downField(\"tasks\").downArray\n    //val x = c2.focus\n    val y = decode[Dag](c2.focus.get.toString)\n    println(\"_\" * 10)\n\n    println(c2.focus.get)\n    println(\"_\" * 10)\n\n    println(y)\n    println(\"_\" * 10)\n\n    //val z = decode[Workflow](j.toString)\n\n    //println(c2.as[Json].getOrElse(Json.Null))\n  }\n\n  test(\"build petri net\") {\n    import LinkableElement._\n    import Arc._\n    val jp1 = \"\"\"{\"id\":1,\"name\":\"start\",\"capacity\":1}\"\"\"\n\n    val p1: Place = decode[Place](jp1).getOrElse(Place(999, \"Error\", 0))\n    val pp1       = p1.asJson.noSpaces\n\n    println(s\"\\nPlace:\\n$pp1\\n\")\n\n    val p2: Place = Place(2, \"left\", 3)\n    val p3: Place = Place(3, \"right\", 1)\n    val p4: Place = Place(4, \"joint\", 3)\n    val p5: Place = Place(5, \"end\", 1)\n\n    // val rpc =\n\n    val jt1 = \"\"\"{\"id\":6,\"name\":\"splitter\",\"capacity\":1}\"\"\"\"\"\"\n    val l   = (l: String) => println(l)\n    val s1 = Service(\n      \"ee.mn8.castanet\",\n      \"HelloFs2Grpc\",\n      List[RPC](RPC(name = \"sayHello\", input = \"\", output = \"\"))\n    )\n    val r1 = s1.rpcs.head\n    // def func(serviceName: String, rpcName: String): Function1[String, Unit] = ???\n    // '{(l: String) => println(l)}\n\n    val t1: Transition = Transition(6, \"splitter\", s1, r1)\n    // val tt1       = t1.asJson.noSpaces\n\n    val t2: Transition = Transition(7, \"joiner\", s1, r1)\n    val t3: Transition = Transition(8, \"continuer\", s1, r1)\n\n    val n    = PetriNetBuilder().addAll(ListSet(p1, p2, p3, p4, p5))\n    val json = List(p1, p2, p3, p4, p5).asJson.spaces2\n    println(s\"\\n\\nJSON LIST:\\n $json\")\n    val ps = decode[List[Place]](json)\n    println(s\"\\n\\nJSON decoded: $ps\")\n\n    val json2 = List(t1, t2, t3).asJson.spaces2\n    println(s\"\\n\\nJSON LIST:\\n $json2\")\n    val ts = decode[List[Transition]](json2)\n    println(s\"\\n\\nJSON decoded: $ts\")\n\n    //arcs = ListSet(Arc.Weighted(from = 1l,to = 2l,weight = 1)), places = ListSet[Place](p1), transitions = ListSet[Transition](Transition(id = 2l, name = \"test\", fn = t)))\n    val n2 = n.addAll(ListSet(t1, t2, t3))\n    val n3 = n2\n      .add(Weighted(1, 6, 1))\n      .add(Weighted(6, 2, 1))\n      .add(Weighted(6, 3, 1))\n      .add(Weighted(2, 7, 2))\n      .add(Weighted(3, 7, 1))\n      .add(Weighted(7, 4, 1))\n      .add(Weighted(4, 8, 3))\n      .add(Weighted(8, 5, 1))\n    //val x = n3.ColouredPetriNet(Map[NodeId,ListSet[LinkableElement]]())\n    println(\"_\" * 10)\n    println(s\"Net 3: $n3\")\n    println(\"_\" * 10)\n    println(s\"Linkables: ${n3.build()}\")\n    println(\"_\" * 10)\n    val pn = n3.build()\n    val places = pn.elements.values.collect { case p: Place =>\n      p\n    }\n    val dimensions = (places.size, places.maxBy(p => p.capacity).capacity)\n    println(dimensions)\n\n    val m1 = Markers(pn)\n    println(s\"${m1}\\n${m1.toStateVector}\")\n\n    val m2 = m1.setMarker(Marker(1, bin\"1\"))\n    println(s\"${m2}\\n${m2.toStateVector}\")\n\n    val m3 = m2.setMarker(Marker(2, bin\"1\")).setMarker(Marker(4, bin\"11\"))\n    println(s\"${m3}\\n${m3.toStateVector}\")\n\n    val m4 = Markers(pn, m3.toStateVector)\n    println(s\"${m4}\\n${m4.toStateVector} \\n${m4.serialize}\")\n\n    val m5 = Markers(pn, m4.serialize)\n    println(s\"${m5}\\n${m5.toStateVector} \\n${m5.serialize}\")\n    PetriPrinter(fileName = \"petrinet1\", petriNet = pn).print(Option(m3))\n    val steps: State[Step, Unit] =\n      for\n        p1 <- pn.step\n        p2 <- pn.step\n        p3 <- pn.step\n      yield (\n        PetriPrinter(fileName = \"petrinet2\", petriNet = pn).print(Option(p1)),\n        PetriPrinter(fileName = \"petrinet3\", petriNet = pn).print(Option(p2)),\n        PetriPrinter(fileName = \"petrinet4\", petriNet = pn).print(Option(p3))\n      )\n    steps.run(Step(m3, true, 1)).value\n\n  }\n}\n"
        }
    ]
}