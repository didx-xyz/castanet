{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 262,
            "patches": [
                {
                    "date": 1629811248156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1629811254728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,4 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n+We derice\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811272664,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derice\n\\ No newline at end of file\n+We derive Transitions from \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811300573,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from \n\\ No newline at end of file\n+We derive Transitions from ProtoBuf fi\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811310878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf fi\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811316562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that \n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811339206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the \n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the k\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811348518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the k\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811354942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC \n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC's we nee\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811361686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC's we nee\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC's we use\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811368791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC's we use\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811375320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811382880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,5 +67,5 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n\\ No newline at end of file\n+We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n"
                },
                {
                    "date": 1629811399574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,4 +68,5 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n+The Transitions are described \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811407426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,5 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n-The Transitions are described \n\\ No newline at end of file\n+The Transitions are described using Dhall\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811412915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,5 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n-The Transitions are described using Dhall\n\\ No newline at end of file\n+The Transitions are described using Dhall format \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811421193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,5 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n-The Transitions are described using Dhall format \n\\ No newline at end of file\n+The Transitions are described using Dhall format lists\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811427103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,5 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n-The Transitions are described using Dhall format lists\n\\ No newline at end of file\n+The Transitions are described using a Dhall format list\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811433426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,5 +68,7 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n-The Transitions are described using a Dhall format list\n\\ No newline at end of file\n+The Transitions are described using a Dhall format list:\n+\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811439442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,5 +70,5 @@\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n-```\n\\ No newline at end of file\n+```\n"
                },
                {
                    "date": 1629811445657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,4 +71,25 @@\n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```\n+[\n+  {\n+      id = 2 \n+    , name = \"testTransition\"\n+    , service = {\n+          packageName = \"packageName1\"\n+        , name = \"serviceName1\"   \n+        , rpcs = [\n+          {name = \"rpc1\"\n+          , input = \"in1\"\n+          , output = \"out1\"\n+          }\n+        ]  \n+    }\n+    , rpc = {name = \"rpc1\"\n+          , input = \"in1\"\n+          , output = \"out1\"\n+          }\n+  }\n+]\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811458004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,5 +91,5 @@\n           , output = \"out1\"\n           }\n   }\n ]\n-```\n\\ No newline at end of file\n+```\n"
                },
                {
                    "date": 1629811479220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,9 @@\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n-```\n+```hocon\n [\n   {\n       id = 2 \n     , name = \"testTransition\"\n"
                },
                {
                    "date": 1629811489842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,9 @@\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n-```hocon\n+```\n [\n   {\n       id = 2 \n     , name = \"testTransition\"\n"
                },
                {
                    "date": 1629811508329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,9 @@\n \n We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n-```\n+```dhall\n [\n   {\n       id = 2 \n     , name = \"testTransition\"\n@@ -92,4 +92,5 @@\n           }\n   }\n ]\n ```\n+\n"
                },
                {
                    "date": 1629811575460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,4 +93,5 @@\n   }\n ]\n ```\n \n+T\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811583658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-T\n\\ No newline at end of file\n+Transitions \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811589595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions \n\\ No newline at end of file\n+Transitions change the State\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811600675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the State\n\\ No newline at end of file\n+Transitions change the State of the Workflow\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811607384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the State of the Workflow\n\\ No newline at end of file\n+Transitions change the State of the Workflow by\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811620033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the State of the Workflow by\n\\ No newline at end of file\n+Transitions change the State of the Workflow \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811629861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the State of the Workflow \n\\ No newline at end of file\n+Transitions change the States of the Workflow \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811636934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the States of the Workflow \n\\ No newline at end of file\n+Transitions change the States of the Workflow as described by\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811643246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,5 @@\n   }\n ]\n ```\n \n-Transitions change the States of the Workflow as described by\n\\ No newline at end of file\n+Transitions change the States of the Workflow as described by a l\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811650502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,5 +93,6 @@\n   }\n ]\n ```\n \n-Transitions change the States of the Workflow as described by a l\n\\ No newline at end of file\n+Transitions change the States of the Workflow as described by a list of Places:\n+\n"
                },
                {
                    "date": 1629811655644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,4 +95,5 @@\n ```\n \n Transitions change the States of the Workflow as described by a list of Places:\n \n+```dhall\n"
                },
                {
                    "date": 1629811670666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,4 +96,9 @@\n \n Transitions change the States of the Workflow as described by a list of Places:\n \n ```dhall\n+  [{\n+    id = 1 \n+    , name = \"place1\"\n+    , capacity = 2\n+  }]\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811675767,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,5 +100,6 @@\n   [{\n     id = 1 \n     , name = \"place1\"\n     , capacity = 2\n-  }]\n\\ No newline at end of file\n+  }]\n+  ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811724874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,5 +101,6 @@\n     id = 1 \n     , name = \"place1\"\n     , capacity = 2\n   }]\n-  ```\n\\ No newline at end of file\n+  ```\n+\n"
                },
                {
                    "date": 1629811733686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,4 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n+The \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811744316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-The \n\\ No newline at end of file\n+The business analyst\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811754792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-The business analyst\n\\ No newline at end of file\n+A business analyst can join the \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811764691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the \n\\ No newline at end of file\n+A business analyst can join the States and \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811772577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the States and \n\\ No newline at end of file\n+A business analyst can join the (States and Transitions\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811779113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the (States and Transitions\n\\ No newline at end of file\n+A business analyst can join the P(States) and Transitions\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811785651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the P(States) and Transitions\n\\ No newline at end of file\n+A business analyst can join the Places (States) and Transitions \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629811796237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the Places (States) and Transitions \n\\ No newline at end of file\n+A business analyst can join the Places (States) and Transitions by drawing Arcs \n\\ No newline at end of file\n"
                },
                {
                    "date": 1629812969969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,5 +103,5 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the Places (States) and Transitions by drawing Arcs \n\\ No newline at end of file\n+A business analyst can join the Places (States) and Transitions by drawing Arcs \n"
                },
                {
                    "date": 1629812988761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,4 +104,5 @@\n   }]\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n+\n"
                },
                {
                    "date": 1629813005475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,4 +105,5 @@\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n \n+![alt text](do/animate.gif \"Petri Net Animation\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629813037534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,5 +105,5 @@\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n \n-![alt text](do/animate.gif \"Petri Net Animation\")\n\\ No newline at end of file\n+![alt text](docs/animate.gif \"Petri Net Animation\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629813105334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,5 +105,5 @@\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n \n-![alt text](docs/animate.gif \"Petri Net Animation\")\n\\ No newline at end of file\n+![alt text](docs/place_transitions.png \"Petri Net Animation\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629813117080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,5 +105,5 @@\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n \n-![alt text](docs/place_transitions.png \"Petri Net Animation\")\n\\ No newline at end of file\n+![alt text](docs/place_transitions.png \"Arcs\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1629813124811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,5 +105,6 @@\n   ```\n \n A business analyst can join the Places (States) and Transitions by drawing Arcs \n \n-![alt text](docs/place_transitions.png \"Arcs\")\n\\ No newline at end of file\n+![alt text](docs/place_transitions.png \"Arcs\")\n+\n"
                },
                {
                    "date": 1629815088068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,8 +103,8 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can join the Places (States) and Transitions by drawing Arcs \n+A business analyst can create a business flowjoin the Places (States) and Transitions by drawing Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n"
                },
                {
                    "date": 1629815105285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,8 +103,8 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can create a business flowjoin the Places (States) and Transitions by drawing Arcs \n+A business analyst can create a business flow by joining the Places (States) and Transitions by drawing Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n"
                },
                {
                    "date": 1629815112898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,8 +103,8 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can create a business flow by joining the Places (States) and Transitions by drawing Arcs \n+A business analyst can create a business flow by joining the Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n"
                },
                {
                    "date": 1629815127625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,8 +103,7 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can create a business flow by joining the Places (States) and Transitions with Arcs \n+A business analyst can create a business flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n-\n"
                },
                {
                    "date": 1629884058640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-# Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n+# Castanet is a Colored Petri Net* for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884064945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n-# Castanet is a Colored Petri Net* for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n+# Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n+\n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n"
                },
                {
                    "date": 1629884070292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n+For \n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884076439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For \n+For now The lo\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884084956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now The lo\n+For now, the \n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884091924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the \n+For now, the Coloured Petri Net\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884098517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the Coloured Petri Net\n+For now, the Coloured Petri Net is like a model T \n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884115557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the Coloured Petri Net is like a model T \n+For now, the Coloured Petri Net is like a model T Ford - any colour as long as it is black\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884124127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the Coloured Petri Net is like a model T Ford - any colour as long as it is black\n+For now, the Coloured Petri Net is like a Model T Ford - any colour as long as it is black\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1629884132099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the Coloured Petri Net is like a Model T Ford - any colour as long as it is black\n+For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1631604105625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black\n+(For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black.\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1631604114491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n-(For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black.\n+(For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n"
                },
                {
                    "date": 1631604928876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,10 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n+\n+\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n"
                },
                {
                    "date": 1631604952499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,10 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n+Unlike these standards, Petri nets have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n-\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n"
                },
                {
                    "date": 1631604965839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Unlike these standards, Petri nets have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631604977287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631604985528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other prchave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631604996994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other prchave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605002988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions (Lhave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605009455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (Lhave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions (like UMhave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605015346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UMhave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN)have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605037160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN)have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they havehave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605048235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they havehave an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis[\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605064699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605231964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605275731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets can be used to \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605361172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets can be used to \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets exhibits \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605370804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets exhibits \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets exhibits Categorical Semantics \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605380983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Petri Nets exhibits Categorical Semantics \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605406936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605413755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable process\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605493287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable process\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605524030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as Monoidal\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605532203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as Monoidal\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as Monoidal Category\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605670089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as Monoidal Category\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal Category\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605698821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal Category\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categor\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605732765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categor\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories that reflects \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605755805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories that reflects \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories that\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605781165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories that\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605788169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories models \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605794885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories models \n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605808506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net compurtations\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605814035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net compurtations\n+Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605827370,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets  are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605839697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605937775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations \n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631605985660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations [[1]] #1\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631606004144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that concatenable processes as strict Monoidal categories model Net computations [[1]] #1\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories model Net computations [[1]] #1\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631606016570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories model Net computations [[1]] #1\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]] #1\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631606025114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,4 +110,5 @@\n \n A business analyst can create a business flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n+\n"
                },
                {
                    "date": 1631606067366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,4 +111,9 @@\n A business analyst can create a business flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n+## References\n+<a id=\"1\">[1]</a> \n+Dijkstra, E. W. (1968). \n+Go to statement considered harmful. \n+Communications of the ACM, 11(3), 147-148.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1631606129611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]] #1\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n@@ -115,5 +115,6 @@\n ## References\n <a id=\"1\">[1]</a> \n Dijkstra, E. W. (1968). \n Go to statement considered harmful. \n+\n Communications of the ACM, 11(3), 147-148.\n\\ No newline at end of file\n"
                },
                {
                    "date": 1631606225309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1)\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n@@ -113,8 +113,5 @@\n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n <a id=\"1\">[1]</a> \n-Dijkstra, E. W. (1968). \n-Go to statement considered harmful. \n-\n-Communications of the ACM, 11(3), 147-148.\n\\ No newline at end of file\n+Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n\\ No newline at end of file\n"
                },
                {
                    "date": 1631606234609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,5 +113,6 @@\n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n <a id=\"1\">[1]</a> \n-Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n\\ No newline at end of file\n+Sassone, V.. (2006). On the category of Petri net computation. \n+10.1007/3-540-59293-8_205. \n\\ No newline at end of file\n"
                },
                {
                    "date": 1631606409100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,10 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1)\n \n+\n+\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n@@ -114,5 +116,6 @@\n \n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. \n+\n 10.1007/3-540-59293-8_205. \n\\ No newline at end of file\n"
                },
                {
                    "date": 1631606950475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1)\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) \n \n \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n"
                },
                {
                    "date": 1631606972266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) \n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]]()\n \n \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n"
                },
                {
                    "date": 1631606982389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]]()\n+Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n@@ -117,5 +117,6 @@\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. \n \n-10.1007/3-540-59293-8_205. \n\\ No newline at end of file\n+10.1007/3-540-59293-8_205. \n+\n"
                },
                {
                    "date": 1631606992252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,4 +119,5 @@\n Sassone, V.. (2006). On the category of Petri net computation. \n \n 10.1007/3-540-59293-8_205. \n \n+<a id=\"1\">[1]</a>\n\\ No newline at end of file\n"
                },
                {
                    "date": 1631607174558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,5 +119,5 @@\n Sassone, V.. (2006). On the category of Petri net computation. \n \n 10.1007/3-540-59293-8_205. \n \n-<a id=\"1\">[1]</a>\n\\ No newline at end of file\n+<a id=\"1\">[2]</a>\n\\ No newline at end of file\n"
                },
                {
                    "date": 1631607180529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,5 +119,5 @@\n Sassone, V.. (2006). On the category of Petri net computation. \n \n 10.1007/3-540-59293-8_205. \n \n-<a id=\"1\">[2]</a>\n\\ No newline at end of file\n+<a id=\"2\">[2]</a>\n\\ No newline at end of file\n"
                },
                {
                    "date": 1631607213329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,9 +115,8 @@\n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n <a id=\"1\">[1]</a> \n-Sassone, V.. (2006). On the category of Petri net computation. \n+Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n \n-10.1007/3-540-59293-8_205. \n-\n\\ No newline at end of file\n-<a id=\"2\">[2]</a>\n+<a id=\"2\">[2]</a>\n+Ermel, Claudia & Martini, Alfio. (1996). A Taste of Categorical Petri Nets. \n\\ No newline at end of file\n"
                },
                {
                    "date": 1631607313296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,10 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n+Pte\n \n-\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n"
                },
                {
                    "date": 1631607332954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pte\n+Pteri Nets are also used for \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607343136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used for \n+Pteri Nets are also used for Liveness, Boundness, \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607377982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used for Liveness, Boundness, \n+Pteri Nets are also used for Liveness, Boundedness, \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607386711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used for Liveness, Boundedness, \n+Pteri Nets are also used for Liveness, Boundedness, an\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607394325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used for Liveness, Boundedness, an\n+Pteri Nets are also used for Liveness, Boundedness and Reachabil,ity\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607407974,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used for Liveness, Boundedness and Reachabil,ity\n+Pteri Nets are also used testingfor Liveness, Boundedness and Reachability \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607419527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used testingfor Liveness, Boundedness and Reachability \n+Pteri Nets are also used validating and testing for Liveness, Boundedness and Reachability \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607430070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing for Liveness, Boundedness and Reachability \n+Pteri Nets are also used validating and testing ftheor Liveness, Boundedness and Reachability \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607435971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing ftheor Liveness, Boundedness and Reachability \n+Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607443114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability \n+Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability o\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607475857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability o\n+Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of network models\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607504329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of network models\n+Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributednetwork models\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607526791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributednetwork models\n+Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networ\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607541585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Pteri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networ\n+Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607548911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks\n+Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607581537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+SictochastPetri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607588920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-SictochastPetri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Stochastic Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607598513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Stochastic Petri Nets are also used validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607749863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Because of itStochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607758062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of itStochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Because of its Markov PropertyStochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631607766693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov PropertyStochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Because of its Markov property,Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631608213734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,10 +6,11 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property,Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n \n+\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n"
                },
                {
                    "date": 1631608218788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks. \n+Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n"
                },
                {
                    "date": 1631608551380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n-\n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n@@ -110,9 +109,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analyst can create a business flow by joining Places (States) and Transitions with Arcs \n+A business analengineeryst can create a business flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n"
                },
                {
                    "date": 1631608560896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business analengineeryst can create a business flow by joining Places (States) and Transitions with Arcs \n+A business engineer can create a business flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n"
                },
                {
                    "date": 1631608571616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,9 +109,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business engineer can create a business flow by joining Places (States) and Transitions with Arcs \n+A business engineer can create a work flow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n"
                },
                {
                    "date": 1631609030939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n \n-Petri nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n+Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n@@ -109,9 +109,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business engineer can create a work flow by joining Places (States) and Transitions with Arcs \n+A business engineer can create a workflow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n \n ## References\n"
                },
                {
                    "date": 1631609092939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property, Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n+Because of its Markov property,  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631609102915,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property,  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n+Because of its Markov property - states depend only on the current marking Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631609114295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property - states depend only on the current marking Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n+Because of its Markov property - states depend only on the current marking,  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631609437765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n It is well suited for describing the flow of concurrent processes.\n \n Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n-Because of its Markov property - states depend only on the current marking,  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n+Because of its Markov property - states depend only on the current marking -  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n Protobuf definitions specify the service and message format for GRPC services.\n"
                },
                {
                    "date": 1631609692339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-# Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n+# Castaneta Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n \n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n"
                },
                {
                    "date": 1631609707277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,8 @@\n-# Castaneta Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n+# Castanet, a Colored Petri Net for GRPC/HTTP orchestration \n \n+(e.g. FS2-GRPC or HTTP4S)\n+\n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n It is well suited for describing the flow of concurrent processes.\n"
                },
                {
                    "date": 1631609729457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet, a Colored Petri Net for GRPC/HTTP orchestration \n \n-(e.g. FS2-GRPC or HTTP4S)\n+e.g. FS2-GRPC or HTTP4S)\n \n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n"
                },
                {
                    "date": 1631609740685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n # Castanet, a Colored Petri Net for GRPC/HTTP orchestration \n \n-e.g. FS2-GRPC or HTTP4S)\n+## e.g. FS2-GRPC or HTTP4S\n \n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n"
                },
                {
                    "date": 1631609852854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n   .add(Weighted(8, 5, 1))\n val petrinet = b3.build()\n ```\n \n-State is attributed to the Petri Net through Markers that associate a BitVectors(scodec.bits) with a specific Place\n+State is attributed to the Petri Net through Markers that associate a BitVector(scodec.bits) with a specific Place\n \n ```scala\n val m1 = Markers(pn)\n val m2 = m1.setMarker(Marker(1, bin\"1\"))\n"
                },
                {
                    "date": 1631609862616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n   .add(Weighted(8, 5, 1))\n val petrinet = b3.build()\n ```\n \n-State is attributed to the Petri Net through Markers that associate a BitVector(scodec.bits) with a specific Place\n+State is attributed to the Petri Net through Markers that associate a BitVector (scodec.bits) with a specific Place.\n \n ```scala\n val m1 = Markers(pn)\n val m2 = m1.setMarker(Marker(1, bin\"1\"))\n"
                },
                {
                    "date": 1631609910620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-# Castanet, a Colored Petri Net for GRPC/HTTP orchestration \n+# Castanet, a Colored Petri Net for GRPC/HTTP orchestration and \n \n ## e.g. FS2-GRPC or HTTP4S\n \n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n"
                },
                {
                    "date": 1631609930121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-# Castanet, a Colored Petri Net for GRPC/HTTP orchestration and \n+# Castanet, a Colored Petri Net for GRPC/HTTP orchestration and testing\n \n ## e.g. FS2-GRPC or HTTP4S\n \n (For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n@@ -114,9 +114,8 @@\n \n A business engineer can create a workflow by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n-\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n \n"
                },
                {
                    "date": 1643273896731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,24 +1,25 @@\n-# Castanet, a Colored Petri Net for GRPC/HTTP orchestration and testing\n+# ErgoHack III Proposal: Using a Colored Petri Net for Smart Contract orchestration and testing\n \n-## e.g. FS2-GRPC or HTTP4S\n+## Implemention of Smart Contract Protocol specifications (EIP-0006)\n \n-(For now, the Coloured Petri Net is like a Model T Ford - you can have any colour as long as it is black).\n+I am proposing a project that uses Petri Nets as a tool to define and validate Smart Contract Protocol specifications (EIP-0006), for creation of headless dApps.\n \n Formally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\n-It is well suited for describing the flow of concurrent processes.\n+It is well suited for describing the flow of concurrent processes. This maps perfectly to the of Stages (Places) and Actions (Transitions)\n \n Petri Nets are more concise than other process flow descriptions (like UML or BPMN) in that they have an exact mathematical definition of their execution semantics, with a well-developed mathematical theory for process analysis. Bounded Petri Nets exhibits Categorical Semantics in the way that **concatenable processes as strict Monoidal categories** model Net computations [[1]](#1) [[2]](#2)\n \n Because of its Markov property - states depend only on the current marking -  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n-From the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\n+From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n-Protobuf definitions specify the service and message format for GRPC services.\n-An GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n \n-Castanet constructs a PetriNet using a builder-pattern\n \n+I contetnd that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n+\n+An example of how to construct a PetriNet using a builder-pattern in Scala ( Using a Petri Net library (Castanet))\n+\n ```scala\n val p1 = Place(1, \"start\", 1)\n val p2 = Place(2, \"left\", 3)\n val p3 = Place(3, \"right\", 1)\n@@ -75,9 +76,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from ProtoBuf files that indicates the RPC's we use in the business flow.\n+We derive Transitions from the  files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643273905410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from the  files that indicates the RPC's we use in the business flow.\n+We derive Transitions from the ErgoScript files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643284369145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n \n \n-I contetnd that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n+We contetnd that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n \n An example of how to construct a PetriNet using a builder-pattern in Scala ( Using a Petri Net library (Castanet))\n \n ```scala\n@@ -44,8 +44,9 @@\n val petrinet = b3.build()\n ```\n \n State is attributed to the Petri Net through Markers that associate a BitVector (scodec.bits) with a specific Place.\n+The setting of a bit is in turn determined by the success of the ErgoScript execution.\n \n ```scala\n val m1 = Markers(pn)\n val m2 = m1.setMarker(Marker(1, bin\"1\"))\n@@ -112,9 +113,10 @@\n     , capacity = 2\n   }]\n   ```\n \n-A business engineer can create a workflow by joining Places (States) and Transitions with Arcs \n+### Outcomes:\n+1. A business analyst should  create a dApp  by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643284413118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,10 +114,11 @@\n   }]\n   ```\n \n ### Outcomes:\n-1. A business analyst should  create a dApp  by joining Places (States) and Transitions with Arcs \n \n+1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n+\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643284419812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,9 +114,8 @@\n   }]\n   ```\n \n ### Outcomes:\n-\n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643284434883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,10 @@\n     , capacity = 2\n   }]\n   ```\n \n-### Outcomes:\n+### Outcomes\n+\n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643284456347,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-### Outcomes\n+### Desired Outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n"
                },
                {
                    "date": 1643284462044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,9 @@\n     , capacity = 2\n   }]\n   ```\n \n-### Desired Outcomes\n+### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n"
                },
                {
                    "date": 1643284475130,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,9 +115,9 @@\n   ```\n \n ### Desired outcomes\n \n-1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs \n+1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643284540108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions from the ErgoScript files that indicates the RPC's we use in the business flow.\n+We derive Transitions (Actoiioins) from the ErgoScript files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643284546443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions (Actoiioins) from the ErgoScript files that indicates the RPC's we use in the business flow.\n+We derive Transitions (Actoins) from the ErgoScript files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643284559911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive Transitions (Actoins) from the ErgoScript files that indicates the RPC's we use in the business flow.\n+We derive the set Transitions (Actions) from the ErgoScript files that indicates the RPC's we use in the business flow.\n The Transitions are described using a Dhall format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643284644507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = \"in1\"\n+          , input = box\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284659123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = box\n+          , input = input boxes\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284680925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = input boxes\n+          , input = [input boxes\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284686958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [input boxes\n+          , input = [boxes\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284695076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [boxes\n+          , input = [inbox\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284701075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [inbox\n+          , input = [inbox,1\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284709236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [inbox,1\n+          , input = [inbox1, inbox2,...\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284715902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [inbox1, inbox2,...\n+          , input = [inbox1, inbox2...\n           , output = \"out1\"\n           }\n         ]  \n     }\n"
                },
                {
                    "date": 1643284724243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,10 +90,10 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n-          , input = [inbox1, inbox2...\n-          , output = \"out1\"\n+          , input = [inbox1, inbox2...]\n+          , output = [out1\"\n           }\n         ]  \n     }\n     , rpc = {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284731783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n-          , output = [out1\"\n+          , output = [outbox1\"\n           }\n         ]  \n     }\n     , rpc = {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284741871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n-          , output = [outbox1\"\n+          , output = [outbox1, outbox\n           }\n         ]  \n     }\n     , rpc = {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284747414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -91,9 +91,9 @@\n         , name = \"serviceName1\"   \n         , rpcs = [\n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n-          , output = [outbox1, outbox\n+          , output = [outbox1, outbox2...\n           }\n         ]  \n     }\n     , rpc = {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284783303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,12 +88,12 @@\n     , name = \"testTransition\"\n     , service = {\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n-        , rpcs = [\n+        , contracts = [\n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n-          , output = [outbox1, outbox2...\n+          , output = [outbox1, outbox2...]\n           }\n         ]  \n     }\n     , rpc = {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284797997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,9 +85,9 @@\n [\n   {\n       id = 2 \n     , name = \"testTransition\"\n-    , service = {\n+    , action = {\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = [\n           {name = \"rpc1\"\n"
                },
                {
                    "date": 1643284832071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,9 @@\n     , name = \"testTransition\"\n     , action = {\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n-        , contracts = [\n+        , contracts = \n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           }\n"
                },
                {
                    "date": 1643284845353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,9 +93,9 @@\n           {name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           }\n-        ]  \n+     \n     }\n     , rpc = {name = \"rpc1\"\n           , input = \"in1\"\n           , output = \"out1\"\n"
                },
                {
                    "date": 1643284870167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,13 +89,13 @@\n     , action = {\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = \n-          {name = \"rpc1\"\n+          {\n+            name = \"rpc1\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n-          }\n-     \n+          } \n     }\n     , rpc = {name = \"rpc1\"\n           , input = \"in1\"\n           , output = \"out1\"\n"
                },
                {
                    "date": 1643284877944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = \n           {\n-            name = \"rpc1\"\n+            name = \"smart\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n"
                },
                {
                    "date": 1643284883084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = \n           {\n-            name = \"smart\"\n+            name = \"\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n"
                },
                {
                    "date": 1643284890363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = \n           {\n-            name = \"\"\n+            name = \"ergoScropt\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n"
                },
                {
                    "date": 1643284896527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -90,9 +90,9 @@\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n         , contracts = \n           {\n-            name = \"ergoScropt\"\n+            name = \"ergoScript\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n"
                },
                {
                    "date": 1643284938783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,11 +88,11 @@\n     , name = \"testTransition\"\n     , action = {\n           packageName = \"packageName1\"\n         , name = \"serviceName1\"   \n-        , contracts = \n+        , contract = \n           {\n-            name = \"ergoScript\"\n+            name = \"ergoScript1\"\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n"
                },
                {
                    "date": 1643284967690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,9 +87,9 @@\n       id = 2 \n     , name = \"testTransition\"\n     , action = {\n           packageName = \"packageName1\"\n-        , name = \"serviceName1\"   \n+        , name = \"Name1\"   \n         , contract = \n           {\n             name = \"ergoScript1\"\n           , input = [inbox1, inbox2...]\n"
                },
                {
                    "date": 1643284995961,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,18 +78,18 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive the set Transitions (Actions) from the ErgoScript files that indicates the RPC's we use in the business flow.\n-The Transitions are described using a Dhall format list:\n+The Transitions are described using a Dhall/ format list:\n \n ```dhall\n [\n   {\n       id = 2 \n     , name = \"testTransition\"\n     , action = {\n           packageName = \"packageName1\"\n-        , name = \"Name1\"   \n+        , name = \"contractName1\"   \n         , contract = \n           {\n             name = \"ergoScript1\"\n           , input = [inbox1, inbox2...]\n"
                },
                {
                    "date": 1643285007156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,10 +77,10 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set Transitions (Actions) from the ErgoScript files that indicates the RPC's we use in the business flow.\n-The Transitions are described using a Dhall/ format list:\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates the RPC's we use in the business flow.\n+The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n   {\n"
                },
                {
                    "date": 1643285029054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates the RPC's we use in the business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates th business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643285038569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates th business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates that detrminnes  business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643285045335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates that detrminnes  business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates that determines  business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643285091698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates that determines  business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates that determines  the business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n@@ -95,9 +95,9 @@\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n-    , rpc = {name = \"rpc1\"\n+    , rpc = {name = \"contractName1\"\n           , input = \"in1\"\n           , output = \"out1\"\n           }\n   }\n"
                },
                {
                    "date": 1643285109339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n           , output = [outbox1, outbox2...]\n           } \n     }\n     , rpc = {name = \"contractName1\"\n-          , input = \"in1\"\n+          , input = \"in1box\"\n           , output = \"out1\"\n           }\n   }\n ]\n"
                },
                {
                    "date": 1643285117849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,10 +96,10 @@\n           , output = [outbox1, outbox2...]\n           } \n     }\n     , rpc = {name = \"contractName1\"\n-          , input = \"in1box\"\n-          , output = \"out1\"\n+          , input = \"inbox3\"\n+          , output = \"out\"\n           }\n   }\n ]\n ```\n"
                },
                {
                    "date": 1643285128627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,11 +95,11 @@\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n-    , rpc = {name = \"contractName1\"\n+    , action = {name = \"contractName1\"\n           , input = \"inbox3\"\n-          , output = \"out\"\n+          , output = \"outbox3\"\n           }\n   }\n ]\n ```\n"
                },
                {
                    "date": 1643285192446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates that determines  the business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that indicates   the business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643285200570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,9 +77,9 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that indicates   the business flow.\n+We derive the set of Transitions (Actions) from the ErgoScript files that controls  the business flow.\n The Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n"
                },
                {
                    "date": 1643285209362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive the set of Transitions (Actions) from the ErgoScript files that controls  the business flow.\n-The Transitions are described using a Dhall/JSON format list:\n+Theses Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n   {\n"
                },
                {
                    "date": 1643285222194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,10 +77,10 @@\n ```\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n-We derive the set of Transitions (Actions) from the ErgoScript files that controls  the business flow.\n-Theses Transitions are described using a Dhall/JSON format list:\n+We derive the set of Transitions (Actions) from  ErgoScript files that controls  the business flow.\n+These Transitions are described using a Dhall/JSON format list:\n \n ```dhall\n [\n   {\n"
                },
                {
                    "date": 1643285232173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n \n ![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n \n We derive the set of Transitions (Actions) from  ErgoScript files that controls  the business flow.\n-These Transitions are described using a Dhall/JSON format list:\n+These Transitions are specified using a Dhall/JSON format list:\n \n ```dhall\n [\n   {\n"
                },
                {
                    "date": 1643285249417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n   }\n ]\n ```\n \n-Transitions change the States of the Workflow as described by a list of Places:\n+Transitions change the States of the Workflow as described by a list of Places ():\n \n ```dhall\n   [{\n     id = 1 \n"
                },
                {
                    "date": 1643285266795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n   }\n ]\n ```\n \n-Transitions change the States of the Workflow as described by a list of Places ():\n+Transitions change the States of the Workflow as described by a list of Places (Stages):\n \n ```dhall\n   [{\n     id = 1 \n"
                },
                {
                    "date": 1643285322604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,8 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n+2. \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285371365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n \n Because of its Markov property - states depend only on the current marking -  Stochastic Petri Nets are also used for validating and testing the Liveness, Boundedness and Reachability of distributed networks.\n \n From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n-It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \n+It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri.  \n \n \n We contetnd that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n \n"
                },
                {
                    "date": 1643285376947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri.  \n \n \n-We contetnd that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n+We contend that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n \n An example of how to construct a PetriNet using a builder-pattern in Scala ( Using a Petri Net library (Castanet))\n \n ```scala\n"
                },
                {
                    "date": 1643285389092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri.  \n \n \n-We contend that there is a need to handle consecutive Smart Contract invocations (the dApp Protoocol) within the context of a encapsualting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n+We contend that there is a need to handle consecutive Smart Contract invocations (the dApp Protocol) within the context of a encapsulting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n \n An example of how to construct a PetriNet using a builder-pattern in Scala ( Using a Petri Net library (Castanet))\n \n ```scala\n"
                },
                {
                    "date": 1643285394616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n From the proposal perspective, Petri Nets are directed graphs consisting of Places(Stages), Transitions(Actions) and Arcs(Transaction). It models state-transitions of (concurrent) processes.\n It is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri.  \n \n \n-We contend that there is a need to handle consecutive Smart Contract invocations (the dApp Protocol) within the context of a encapsulting state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n+We contend that there is a need to handle consecutive Smart Contract invocations (the dApp Protocol) within the context of a encapsulating state machine (FSM) as expressed by a Petri Net and executed by an off-chain dApp-container\n \n An example of how to construct a PetriNet using a builder-pattern in Scala ( Using a Petri Net library (Castanet))\n \n ```scala\n"
                },
                {
                    "date": 1643285494800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. \n+2. Configuration of a specific \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285503076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific \n+2. Configuration of a specific instance \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285510265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance \n+2. Configuration of a specific instance of a dApp\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285518723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp\n+2. Configuration of a specific instance of a dApp \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285632654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp \n+2. Configuration of a specific instance of a dApp can be \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285641325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be \n+2. Configuration of a specific instance of a dApp can be prgrammaticaslly created\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285652066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be prgrammaticaslly created\n+2. Configuration of a specific instance of a dApp can be programmatically created\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285700451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created\n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285712994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI \n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the \n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285718682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the \n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285724818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless\n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285752830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp\n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GR\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285766339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GR\n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285771526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n \n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n-2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP\n+2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643285833621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -95,9 +95,9 @@\n           , input = [inbox1, inbox2...]\n           , output = [outbox1, outbox2...]\n           } \n     }\n-    , action = {name = \"contractName1\"\n+    , action = {name = \"contractName2\"\n           , input = \"inbox3\"\n           , output = \"outbox3\"\n           }\n   }\n"
                },
                {
                    "date": 1643285883259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-\n+3. \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643285901766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. \n+3. Design patterns \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643285936679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns \n+3. Design patterns can be encoded \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643285965633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns can be encoded \n+3. Design patterns can be encoded in \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286006766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns can be encoded in \n+3. Design patterns \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286033048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns \n+3. Design patterns that will be supported by the \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286045964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns that will be supported by the \n+3. Design patterns that will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286059940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,10 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Design patterns that will be supported by the Petri Net:\n+3. \n+4. Design patterns that will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286106057,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. \n+3. The \n 4. Design patterns that will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286117980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. The \n+3. The State Engine will decoupled from the \n 4. Design patterns that will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286142051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. The State Engine will decoupled from the \n+3. \n 4. Design patterns that will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286168951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. \n-4. Design patterns that will be supported by the Petri Net:\n+4. Design patterns  will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286217948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,10 +117,10 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. \n-4. Design patterns  will be supported by the Petri Net:\n+3. Smart Contract templates\n+4. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286223892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates\n+3. Smart Contract templates will \n 4. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286230219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will \n+3. Smart Contract templates will allow reuse of \n 4. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286256673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,10 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Design patterns will be supported by the Petri Net:\n+4. \n+5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286300456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. \n+4. The \n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286315904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. The \n+4. \n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286322585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. \n+4. Validation and \n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286331407,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Validation and \n+4. Validation and Completeness\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286376370,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Validation and Completeness\n+4. Validation of dApp\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286381459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Validation of dApp\n+4. Validation of dApp can be \n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286394682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Validation of dApp can be \n+4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability \n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286400262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -118,9 +118,9 @@\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse of \n-4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability \n+4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n"
                },
                {
                    "date": 1643286435704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will allow reuse of \n+3. Smart Contract templates will allow reuse \n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643286443718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will allow reuse \n+3. Smart Contract templates will allow reuse annd create a possible m\n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643286449847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will allow reuse annd create a possible m\n+3. Smart Contract templates will allow reuse annd create a possible market place of tested \n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643286457360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will allow reuse annd create a possible market place of tested \n+3. Smart Contract templates will allow reuse annd create a possible market place of tested Contracts\n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643286466984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n ### Desired outcomes\n \n 1. A business analyst should  create a dApp Protocol by joining Places (States) and Transitions with Arcs\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n-3. Smart Contract templates will allow reuse annd create a possible market place of tested Contracts\n+3. Smart Contract templates will allow reuse and create a possible market place of tested Contracts\n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n"
                },
                {
                    "date": 1643286473380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,8 +120,9 @@\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse and create a possible market place of tested Contracts\n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n+6. \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n"
                },
                {
                    "date": 1643286484592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,11 +120,12 @@\n 2. Configuration of a specific instance of a dApp can be programmatically created or be informed by the UI connecting to the headless dApp through a GRPC/HTTP API\n 3. Smart Contract templates will allow reuse and create a possible market place of tested Contracts\n 4. Validation of dApp can be done in terms of Liveness, Boundedness and Reachability\n 5. Design patterns will be supported by the Petri Net:\n-6. \n+\n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n+\n <a id=\"1\">[1]</a> \n Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n \n <a id=\"2\">[2]</a>\n"
                },
                {
                    "date": 1643286495181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,9 @@\n \n ![alt text](docs/place_transitions.png \"Arcs\")\n ## References\n \n-<a id=\"1\">[1]</a> \n-Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205. \n+<a id=\"1\">[1]</a>\n+Sassone, V.. (2006). On the category of Petri net computation. 10.1007/3-540-59293-8_205\n \n <a id=\"2\">[2]</a>\n Ermel, Claudia & Martini, Alfio. (1996). A Taste of Categorical Petri Nets. \n\\ No newline at end of file\n"
                }
            ],
            "date": 1629811248156,
            "name": "Commit-0",
            "content": "# Castanet is a Colored Petri Net for GRPC/HTTP orchestration (e.g. FS2-GRPC or HTTP4S)\n\nFormally, a Petri Net is a state transition graph that maps Places (circles) to Transitions (rectangles) and Transitions to Places via Arcs (arrows).\nIt is well suited for describing the flow of concurrent processes.\n\nFrom the Castanet perspective, Petri Nets are directed graphs consisting of Places(States), Transitions(Services) and Arcs(Guards). It models state-transitions of (concurrent) processes.\nIt is easy to see (if you are that way inclined) that Petri Nets form a Category of Petri  \nProtobuf definitions specify the service and message format for GRPC services.\nAn GRPC/HTTP call is assumed to be stateless, yet often there is a need to have service calls handled within the context of a state machine (FSM)\n\nCastanet constructs a PetriNet using a builder-pattern\n\n```scala\nval p1 = Place(1, \"start\", 1)\nval p2 = Place(2, \"left\", 3)\nval p3 = Place(3, \"right\", 1)\nval p4 = Place(4, \"joint\", 3)\nval p5 = Place(5, \"end\", 1)\n\nval t1 = Transition(6, \"splitter\", (l: LinkableElement) => println(l))\nval t2 = Transition(7, \"joiner\", (l: LinkableElement) => println(l))\nval t3 = Transition(8, \"continuer\", (l: LinkableElement) => println(l))\n\nval b1 = PetriNetBuilder().addAll(ListSet(p1, p2, p3, p4, p5))\nval b2 = n.addAll(ListSet(t1, t2, t3))\nval b3 = n2\n  .add(Weighted(1, 6, 1))\n  .add(Weighted(6, 2, 1))\n  .add(Weighted(6, 3, 1))\n  .add(Weighted(2, 7, 2))\n  .add(Weighted(3, 7, 1))\n  .add(Weighted(7, 4, 1))\n  .add(Weighted(4, 8, 3))\n  .add(Weighted(8, 5, 1))\nval petrinet = b3.build()\n```\n\nState is attributed to the Petri Net through Markers that associate a BitVectors(scodec.bits) with a specific Place\n\n```scala\nval m1 = Markers(pn)\nval m2 = m1.setMarker(Marker(1, bin\"1\"))\nval m3 = m2.setMarker(Marker(2, bin\"1\")).setMarker(Marker(4, bin\"11\"))\n```\n\n![alt text](modules/core/src/test/resource/petrinet1.png \"Petri Net 1\")\n\nFor a given set of Markers (current state) the PetriNet can be asked to step through to the next state (set of markers) as indicated by the guards placed on the Arcs that join Places and Transitions.\n\nA ColouredPetrNet is traversable using a state monad to step from an initial state\n\nThe resulting state changes can be visualized with a PetriPrinter.\n\n```scala\n    PetriPrinter(fileName = \"petrinet1\", petriNet = pn).print(Option(m3))\n    val steps: State[Step, Unit] =\n      for\n        p1 <- pn.step\n        p2 <- pn.step\n        p3 <- pn.step\n      yield (\n        PetriPrinter(fileName = \"petrinet2\", petriNet = pn).print(Option(p1)),\n        PetriPrinter(fileName = \"petrinet3\", petriNet = pn).print(Option(p2)),\n        PetriPrinter(fileName = \"petrinet4\", petriNet = pn).print(Option(p3))\n      )\n    steps.run(Step(m3, true, 1)).value\n```\n\n![alt text](modules/core/src/test/resource/animate.gif \"Petri Net Animation\")\n\n"
        }
    ]
}